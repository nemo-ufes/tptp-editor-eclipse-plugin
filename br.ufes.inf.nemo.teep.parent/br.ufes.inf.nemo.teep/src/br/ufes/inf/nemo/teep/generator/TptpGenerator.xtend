/*
 * generated by Xtext 2.25.0
 */
package br.ufes.inf.nemo.teep.generator

import br.ufes.inf.nemo.teep.tptp.AndExpression
import br.ufes.inf.nemo.teep.tptp.AnnotatedFormula
import br.ufes.inf.nemo.teep.tptp.BinaryNonAssociativeExpression
import br.ufes.inf.nemo.teep.tptp.CommentSentence
import br.ufes.inf.nemo.teep.tptp.Constant
import br.ufes.inf.nemo.teep.tptp.Expression
import br.ufes.inf.nemo.teep.tptp.InfixComparisonExpression
import br.ufes.inf.nemo.teep.tptp.NegationExpression
import br.ufes.inf.nemo.teep.tptp.OrExpression
import br.ufes.inf.nemo.teep.tptp.Predicate
import br.ufes.inf.nemo.teep.tptp.QuantifiedExpression
import br.ufes.inf.nemo.teep.tptp.Specification
import br.ufes.inf.nemo.teep.tptp.Variable
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.ufes.inf.nemo.teep.tptp.Functor
import br.ufes.inf.nemo.teep.tptp.NumberLiteral

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TptpGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

/// FIXME: add comments in the generated tex and html for name and role (role also in clif)
/// FIXME: generate html page with index for the annotated formulae
/// TODO: linebreaks and indentation
		val toMathML = new MapToMathML as Mapping
		val toMathJax = new MapToMathJax as Mapping
		val toUnicode = new MapToUnicode as Mapping
		val toTeX = new MapToTeX as Mapping
		val toItemizedTeX = new MapToTeXItemized as Mapping
		
		val toClif = new MapToClif as Mapping

		val spec = resource.contents.get(0) as Specification
		val filename = resource.getURI().lastSegment

		fsa.generateFile(filename + '_plain.html', '''
			«toMathML.preamble»
			«FOR s : spec.sentences»
				«IF (s instanceof CommentSentence)»
				<!-- «s.comment.substring(2,s.comment.length-1).trim» -->
				«ENDIF»
				«IF (s instanceof AnnotatedFormula)»
				<!-- «s.name»  «s.role» -->
				«toMathML.beginning»
				«s.expr.convertSentence(toMathML)»
				«toMathML.end»
				«ENDIF»
			«ENDFOR»
			«toMathML.tailpiece»
		''')

		fsa.generateFile(filename + '_mathjax.html', '''
			«toMathJax.preamble»
			«FOR s : spec.sentences»
				«IF (s instanceof AnnotatedFormula)»
				<!-- «s.name»  «s.role» -->
				«toMathJax.beginning»
				«s.expr.convertSentence(toMathJax)»
				«toMathJax.end»
				«ENDIF»				
			«ENDFOR»
			«toMathJax.tailpiece»
		''')

		fsa.generateFile(filename + '_array.tex', '''
			«toTeX.preamble»
			«FOR s : spec.sentences»
				«IF (s instanceof CommentSentence)»
				% «s.comment.substring(2,s.comment.length-1).trim»
				«ENDIF»
				«IF (s instanceof AnnotatedFormula)»
				% «s.name»  «s.role»
				«toTeX.beginning»
				«s.expr.convertSentence(toTeX)»
				«toTeX.end»
				«ENDIF»
			«ENDFOR»
			«toTeX.tailpiece»
		''')

		fsa.generateFile(filename + '_itemized.tex', '''
			«toItemizedTeX.preamble»
			«FOR s : spec.sentences»
				«IF (s instanceof CommentSentence)»
				% «s.comment.substring(2,s.comment.length-1).trim»
				«ENDIF»			
				«IF (s instanceof AnnotatedFormula)»
				% «s.name»  «s.role»
				«toItemizedTeX.beginning»
				«s.expr.convertSentence(toItemizedTeX)»
				«toItemizedTeX.end»
				«ENDIF»
			«ENDFOR»
			«toItemizedTeX.tailpiece»
		''')

		fsa.generateFile(filename + '.txt', '''
			«FOR s : spec.sentences»
				«IF (s instanceof CommentSentence)»
				«s.comment.substring(2,s.comment.length-1).trim»
				«ENDIF»
				«IF (s instanceof AnnotatedFormula)»
				«s.role» «s.name»:
				«toUnicode.beginning»
				«s.expr.convertSentence(toUnicode)»
				«toUnicode.end»
				«ENDIF»
			«ENDFOR»
		''')

		// FIXME: trimming is a bit radical for comments, check comments for need to escape single quote
		fsa.generateFile(filename + '.clif', '''
			«FOR s : spec.sentences»
				«IF (s instanceof CommentSentence)»(cl-comment '«s.comment.substring(2,s.comment.length-1).trim.replace("'", "\\'")»')«ENDIF»
				«IF (s instanceof AnnotatedFormula)»(cl-comment '«s.role»')
				«toClif.beginning» «s.name»
				«s.expr.convertSentence(toClif)»
				«toClif.end»«ENDIF»
			«ENDFOR»
		''')

	}
	
	/**
 	* 	convertSentence needs special treatment for ordering in clif
 	*/
 
 	def dispatch String convertSentence(QuantifiedExpression qs, MapToClif m) '''
		«m.open»«IF (qs.quantifier=="!")»«m.forall»«ENDIF»«IF (qs.quantifier=="?")»«m.exists»«ENDIF» «FOR var_ : qs.variables BEFORE m.open SEPARATOR ' ' AFTER m.close»«convertTerm(var_, m)»«ENDFOR»
			«convertSentence(qs.formula, m)»«m.close»
	'''

 	def dispatch String convertSentence(BinaryNonAssociativeExpression expr, MapToClif m) '''
		«m.open»«IF (expr.operator=="<=>")»«m.iff»«ENDIF»«IF (expr.operator=="=>")»«m.if_»«ENDIF» «convertSentence(expr.left, m)»
			«convertSentence(expr.right, m)»«m.close»
	'''
	
	def dispatch String convertSentence(AndExpression expr, MapToClif m) {
		var convertedString = new String
		
		convertedString += m.open()
		convertedString += m.and()
		convertedString += " "
		var i = 0
		for (operand : expr.operands) {
			convertedString += convertSentence(operand, m);
			if (i < expr.operands.size() - 1)
				convertedString += " ";
			i++
		}
		convertedString += m.close()
		return convertedString
	}
	
	
	def dispatch String convertSentence(OrExpression expr, MapToClif m) {
		var convertedString = new String
		
		convertedString += m.open()
		convertedString += m.or()
		convertedString += " "
		var i = 0
		for (operand : expr.operands) {
			convertedString += convertSentence(operand, m);
			if (i < expr.operands.size() - 1)
				convertedString += " ";
			i++
		}
		convertedString += m.close()
		return convertedString
	}

	def dispatch String convertSentence(NegationExpression expr, MapToClif m) {
		var convertedString = new String;
		
		convertedString += m.open();
		convertedString += m.not();
		convertedString += " ";

		convertedString += convertSentence(expr.operand, m);
		convertedString += m.close();
		return convertedString
	}

	def dispatch String convertSentence(InfixComparisonExpression e, MapToClif m) {
		var convertedString = new String;

		if (e.operator.equals("="))
		{		
			convertedString += m.open();
			convertedString += m.equals_();
			convertedString += " ";
			convertedString += convertTerm(e.left, m); 

			convertedString += " ";
			convertedString += convertTerm(e.right, m);
			convertedString += m.close();
			return convertedString
		}
		else
		{
			convertedString += m.open();
			convertedString += m.not();
			convertedString += " ";
			convertedString += m.open();
			convertedString += m.equals_();
			convertedString += " ";
			convertedString += convertTerm(e.left, m); 

			convertedString += " ";
			convertedString += convertTerm(e.right, m);

			convertedString += m.close();
			convertedString += m.close();
			return convertedString
		}
	}

	def dispatch String convertSentence(Predicate p, MapToClif m) {
		var convertedString = new String
		
		convertedString += m.open();
		convertedString += m.predicate(p.name);
		convertedString += " ";
		var i = 0;
		for (t : p.terms) {
			convertedString += convertTerm(t, m); 
			if (i < p.terms.size() - 1)
				convertedString += " ";
			i++;
		}
		convertedString += m.close();
		return convertedString;
	}
	
	def dispatch String convertTerm(Functor f, MapToClif m) {
		var convertedString = new String
		
		convertedString += m.open();
		convertedString += m.predicate(f.name);
		convertedString += " ";
		var i = 0;
		for (t : f.terms) {
			convertedString += convertTerm(t, m); 
			if (i < f.terms.size() - 1)
				convertedString += " ";
			i++;
		}
		convertedString += m.close();
		return convertedString;
	}
	
	
	/**
	 * Original conversion (just not applicable to clif, but for every other mapping)
	 */

	def dispatch String convertSentence(QuantifiedExpression qs, Mapping m) {
		var convertedString = new String;
		convertedString += switch (qs.quantifier) {
			case "!": m.forall()
			case "?": m.exists()
		}
		var i = 0;

		for (var_ : qs.variables) {
			convertedString += convertTerm(var_, m);
			if (i < qs.variables.size() - 1) {
				convertedString += m.comma();
			}
			i++;
		}

		convertedString += m.open(); // TODO: consider space instead. precedence of logic operators
		convertedString += convertSentence(qs.formula, m);
		convertedString += m.close();
		return convertedString;
	}

	def dispatch String convertSentence(BinaryNonAssociativeExpression expr, Mapping m) {
		var convertedString = new String;

		if (expr.left instanceof BinaryNonAssociativeExpression) {
			convertedString += m.open();
		} // /
		convertedString += convertSentence(expr.left, m);
		if (expr.left instanceof BinaryNonAssociativeExpression) {
			convertedString += m.close();
		} // /
		convertedString += switch (expr.operator) {
			case "<=>": m.iff()
			case "=>": m.if_()
		// FIXME support other kinds of operators
		// <nonassoc_connective>  ::= <=> | => | <= | <~> | ~<vline> | ~&
		}

		if (expr.right instanceof BinaryNonAssociativeExpression) {
			convertedString += m.open();
		} // /
		convertedString += convertSentence(expr.right, m);
		if (expr.right instanceof BinaryNonAssociativeExpression) {
			convertedString += m.close();
		} // /
		return convertedString;
	}

	def dispatch String convertSentence(AndExpression expr, Mapping m) {
		var convertedString = new String
//		convertedString += m.open()
		var i = 0
		for (operand : expr.operands) {
			if ((operand instanceof OrExpression) || (operand instanceof InfixComparisonExpression)) {
				convertedString += m.open();
			} // /
			convertedString += convertSentence(operand, m);
			if ((operand instanceof OrExpression) || (operand instanceof InfixComparisonExpression)) {
				convertedString += m.close();
			} // /
			if (i < expr.operands.size() - 1)
				convertedString += m.and();
			i++
		}
//		convertedString += m.close()
		return convertedString
	}

	def dispatch String convertSentence(OrExpression expr, Mapping m) {
		var convertedString = new String
		// convertedString += m.open()
		var i = 0
		for (operand : expr.operands) {

			if ((operand instanceof AndExpression) || (operand instanceof InfixComparisonExpression)) {
				convertedString += m.open();
			} // /			
			convertedString += convertSentence(operand, m);
			if ((operand instanceof AndExpression) || (operand instanceof InfixComparisonExpression)) {
				convertedString += m.close();
			} // /
			if (i < expr.operands.size() - 1)
				convertedString += m.or();
			i++
		}
//		convertedString += m.close()
		return convertedString
	}

	def dispatch String convertSentence(NegationExpression expr, Mapping m) {
		var convertedString = new String;
		convertedString += m.not();
		if ((expr.operand instanceof AndExpression) || (expr.operand instanceof OrExpression) ||
			(expr.operand instanceof InfixComparisonExpression) ||
			(expr.operand instanceof BinaryNonAssociativeExpression)) {
			convertedString += m.open();
		} // /			
		convertedString += convertSentence(expr.operand, m);
		if ((expr.operand instanceof AndExpression) || (expr.operand instanceof OrExpression) ||
			(expr.operand instanceof InfixComparisonExpression) ||
			(expr.operand instanceof BinaryNonAssociativeExpression)) {
			convertedString += m.close();
		} // /	
		return convertedString
	}


	def dispatch String convertSentence(InfixComparisonExpression e, Mapping m) {
		var convertedString = new String;
		convertedString += convertTerm(e.left, m);
		if (e.operator.equals("="))
		{
			convertedString += m.equals_();
			}
		else {
			convertedString += m.notequals();
			}
//
		convertedString += convertTerm(e.right, m);
		return convertedString
	}

	def dispatch String convertSentence(Predicate p, Mapping m) {
		var convertedString = new String
		convertedString += m.predicate(p.name);
		convertedString += m.open();
		var i = 0;
		for (t : p.terms) {
			convertedString += convertTerm(t, m); 
			if (i < p.terms.size() - 1)
				convertedString += m.comma();
			i++;
		}
		convertedString += m.close();
		return convertedString;
	}
	
	def dispatch String convertSentence(Constant c, Mapping m) {
		return m.constant(c.name.toFirstUpper);
	}

	def dispatch String convertTerm(Variable v, Mapping m) {
		return m.variable(v.name.toLowerCase);
	}

	def dispatch String convertTerm(Constant c, Mapping m) {
		return m.constant(c.name.toFirstUpper);
	}
	
	def dispatch String convertTerm(NumberLiteral n, Mapping m) {
		return m.numberLiteral(n.literal);
	}
	
	def dispatch String convertTerm(Functor f, Mapping m) {
		var convertedString = new String
		convertedString += m.predicate(f.name);
		convertedString += m.open();
		var i = 0;
		for (t : f.terms) {
			convertedString += convertTerm(t, m);
			
			if (i < f.terms.size() - 1)
				convertedString += m.comma();
			i++;
		}
		convertedString += m.close();
		return convertedString;
	}
	

	def dispatch convertSentence(Expression e, Mapping m) '''
		«e.toString» 		
	'''

}

interface Mapping {
	def String preamble()

	def String beginning()

	def String forall()

	def String exists()

	def String existsOne()

	// also used for functor
	def String predicate(String name)

	def String variable(String name)

	def String numberLiteral(String literal)

	def String constant(String name)

	def String open()

	def String close()

	def String iff()

	def String if_()

	def String not()

	def String and()

	def String or()

	def String comma()

	def String colon()

	def String end()

	def String equals_()
	
	def String notequals()

	def String comment(String string)

	def String tailpiece()
	
}

class MapToClif implements Mapping {
		
	override String beginning() {
		return "(cl-text ";
	}

	override String forall() {
		return "forall";
	}

	override String exists() {
		return "exists";
	}

	override String existsOne() {
		return "∃!";
	}

	override String predicate(String name) {
		return name;
	}

	override String variable(String name) {
		return name;
	}

	override String numberLiteral(String literal) {
		return literal;
	}
	
	override String constant(String name) {
		return name;
	}

	override String open() {
		return "(";
	}

	override String close() {
		return ")";
	}

	override String iff() {
		return "iff";
	}

	override String if_() {
		return "if";
	}

	override String not() {
		return "not";
	}

	override String and() {
		return "and";
	}

	override String or() {
		return "or";
	}

	override String end() {
		return ")";
	}

	override String comma() {
		return " ";
	}

	override String colon() {
		return ":";
	}

	override String equals_() {
		return "=";
	}

	override String notequals() {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

	override comment(String string) {
		return string;
	}

	override preamble() {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

	override tailpiece() {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

}

class MapToMathML implements Mapping {

	override String preamble() '''
		<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
		<html>
		  <head>
		    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
		    <title>MathML Document</title>
		  </head>
		  <body>
	'''

	override String beginning() '''
			<p>
			<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
	'''

	override String forall() {
		return "<mo>&#x2200;<!-- ∀ --></mo>";
	}

	override String exists() {
		return "<mo>&#x2203;<!-- ∃ --></mo>";
	}

	override String existsOne() {
		return "<mo>&#x2203;!<!-- ∃! --></mo>";
	}

	override String predicate(String name) {
		return "<mi mathvariant=\"normal\">" + name + "</mi>";
	}

	override String numberLiteral(String literal) {
		return "<mn>" + literal + "</mn>";
	}
	
	override String constant(String name) {
		return "<mi mathvariant=\"normal\">" + name + "</mi>";
	}

	override String variable(String name) {
		if (name.indexOf("_") != -1)
			// treat superscript
			return "<msub>" + "<mi mathvariant=\"italic\">" + name.substring(0, name.indexOf("_")) + "</mi>" +
				"<mi mathvariant=\"italic\">" + name.substring(name.indexOf("_") + 1, name.length()) + "</mi>" +
				"</msub>";
		return "<mi mathvariant=\"italic\">" + name + "</mi>";
	}

	override String open() {
		return "<mo stretchy=\"false\">(</mo>";
	}

	override String close() {
		return "<mo stretchy=\"false\">)</mo>";
	}

	override String iff() {
		return "<mo stretchy=\"false\">&#x2194;</mo>";
	}

	override String if_() {
		return "<mo stretchy=\"false\">&#x2192;<!-- → --></mo>";
	}

	override String not() {
		return "<mo>&#x00AC;<!-- ¬ --></mo>";
	}

	override String and() {
		return "<mo>&#x2227;<!-- ∧ --></mo>";
	}

	override String or() {
		return "<mo>&#x2228;<!-- ∨ --></mo>";
	}

	override String comma() {
		return "<mo>,</mo>";
	}

	override String colon() {
		return "<mo>:</mo>";
	}

	override String equals_() {
		return "<mo>=</mo>";
	}

	override String notequals() {
		return "<mo>&#x2260;<!-- ≠ --></mo>";
	}

	override String end() {
		return "</math>\n</p>";
	}

	override comment(String string) {
		return "<!-- " + string + " -->"
	}

	override tailpiece() {
		'''
			  </body>
			</html>
		'''
	}

}

class MapToUnicode implements Mapping {
	override String beginning() {
		return "";
	}

	override String forall() {
		return "∀";
	}

	override String exists() {
		return "∃";
	}

	override String existsOne() {
		return "∃!";
	}

	override String predicate(String name) {
		return name;
	}

	override String variable(String name) {
		return name;
	}

	override String numberLiteral(String literal) {
		return literal;
	}

	override String constant(String name) {
		return name;
	}

	override String open() {
		return "(";
	}

	override String close() {
		return ")";
	}

	override String iff() {
		return "↔";
	}

	override String if_() {
		return "→";
	}

	override String not() {
		return "¬";
	}

	override String and() {
		return "∧";
	}

	override String or() {
		return "∨";
	}

	override String end() {
		return "\n";
	}

	override String comma() {
		return ",";
	}

	override String colon() {
		return ":";
	}

	override String equals_() {
		return "=";
	}

	override String notequals() {
		return "≠";
	}

	override comment(String string) {
		return string;
	}

	override preamble() {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

	override tailpiece() {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}

}

class MapToTeX implements Mapping {
	override String beginning() {
		return "\\begin{eqnarray}";
	}

	override String forall() {
		return "\\forall ";
	}

	override String exists() {
		return "\\exists ";
	}

	override String existsOne() {
		return "\\exists ! ";
	}

	override String predicate(String name) {
		return "\\textsf{" + name.replace("_", "\\_") + "}";
	}

	override String variable(String name) {
		return name;
	}
	
	override String numberLiteral(String literal) {
		return literal;
	}

	override String constant(String name) {
		return name;
	}

	override String open() {
		return "(";
	}

	override String close() {
		return ")";
	}

	override String iff() {
		return "\\leftrightarrow ";
	}

	override String if_() {
		return "\\rightarrow ";
	}

	override String not() {
		return "\\neg ";
	}

	override String and() {
		return "\\wedge ";
	}

	override String or() {
		return "\\vee ";
	}

	override String end() {
		return "\\end{eqnarray}";
	}

	override String comma() {
		return ",";
	}

	override String colon() {
		return ":";
	}

	override String equals_() {
		return "=";
	}

	override String notequals() {
		return "\\neq ";
	}

	override comment(String string) {
		return string;
	}

	override preamble() {
		'''
			\documentclass{article}
			\usepackage[utf8]{inputenc}
			\begin{document}
		'''
	}

	override tailpiece() {
		'''
			\end{document}
		'''
	}

}

class MapToMathJax extends MapToTeX {
	override preamble() {
		'''
			<!DOCTYPE html>
			<html>
			<head>
			    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
			    <title>MathJax Document</title>
			</head>
			<body>
		'''
	}

	override String beginning() {
		return "$$";
	}

	override String end() {
		return "$$";
	}

	override String predicate(String name) {
		return "\\textsf{" + name + "}";   // overriden because does not need escaping the underscore
	}

	override tailpiece() {
		'''
			</body>
			</html>
		'''
	}

}

class MapToTeXItemized extends MapToTeX {
	override preamble() {
		'''
			\documentclass{article}
			\usepackage[utf8]{inputenc}
			\begin{document}
			
			\begin{enumerate}
		'''
	}

	override String beginning() {
		return "\\item $";
	}

	override String end() {
		return "$";
	}

	override tailpiece() {
		'''
			\end{enumerate}
			
			\end{document}
		'''
	}
}
